%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[a4paper, total={7in, 10in}]{geometry}

%\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[utf8]{inputenc} 
\usepackage[czech]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{paracol}

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
	\normalfont \normalsize 
	\textsc{Masarykova Univerzita, Fakulta Informatiky} \\ [25pt] % Your university, school and/or department name(s)
	\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
	\huge Sada 2 \\ % The assignment title
	\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Samuel Pastva (410286)} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\begin{itemize}
	
	\section{Obecné pojmy}
	
	\subsection{Grafy}
	
	\item Neorientovaný graf $(V, E)$ kde $e \in E$ sú dvojprvkové podmnožiny $V$ (neusporiadné).
	
	\item Orientovaný graf $(V, E)$ kde $E \subseteq V \times V$.
	
	\item Izomorfixmus grafov $G \simeq H$: $f: V(G) \to V(H)$ t.ž. $(u,v) \in E(G)$ iff $(f(u), f(v)) \in E(H)$.
	
	\item Planárny (rovinný) graf: Dá sa nakresliť do roviny bez pretínania hrán.
	
	\item (Silno) súvislá komponenta — zo všetký vrcholov viem dosiahnuť všetky vrcholy.
	
	\subsection{Výroková logika}		
	
	\item Booleovská funkcia $F : [0,1]^n \to [0,1]$. Operátory $\land, \lor, \neg, \implies, ...$ sú funkcie. 
	
	\item Formula v systéme $\mathcal{L}(F_0, ..., F_n)$: $\varphi ::= x \in Var \mid F_i(\varphi_0, ..., \varphi_m)$
	
	\item Modelom formule je valuácia literálov $v : Var \to [0,1]$: $v \models \varphi$
	
	\item Pravdivá/nepravdivá $v \models \varphi$, splniteľná $\exists v : v \models \varphi$, tautológia $\forall v : v \models \varphi$ ($\models \varphi$)

	\item $\varphi$ je tautologický dôsledok: $T \models \varphi$ (bez ohľadu na model)
	
	\item Normálny tvar: CNF/DNF (klauzula, duálna klauzula, literál)

	\subsection{Logika prvého rádu}
	
	\item Premenné $Var : x, ...$, funkčné symboly $F : f_0, ...$, predikátové symboly $\mathcal{P} : P_0, ...$
	
	\item Jazyk: Sada funkčných a predikátových symbolov 
	
	\item Realizácia $\mathcal{M}$: Univerzum $M$, relácie $P_i \subseteq M^{m}$, funkcie $f_i : M^{m} \to M$
	
	\item \textbf{S rovnosťou vs. bez rovnosti}
	
	\item Term: $t ::= x \in Var \mid f_i(t_0, ..., t_m)$
	
	\item Formula $\varphi ::= P_i(t_0, ..., t_m) \mid (t_0 = t_1) \mid \varphi_0 \to \varphi_1 \mid \neg \varphi_0 \mid \exists x : \varphi$
	
	\item Modelom formule je realizácia a valuácia $v : Var \to M$: $(\mathcal{M}, v) \models \varphi$
	
	\item Pravdivá $\mathcal{M} \models \varphi$ (bez ohľadu na valuáciu)
	
	\item $\varphi$ je sémantický dôsledok: $T \models \varphi$ (bez ohľadu na model)
	
	\item Teória $T$ je množina axiómov. Teória má model $\mathcal{M}$ ak sú v nej všetky axiómy $T$ pravdivé.

	\subsection{Odvodzovacie systémy}
	
	\item Sada (generických) axiómov a syntaktických odvodzovacích pravidiel.
	
	\item Dôkaz: Postupnosť $\varphi_0, \varphi_1, ...$ kde $\varphi_i$ je axióm, alebo $\varphi_i$ vznikne pravidlom z $\varphi_j : j < i$.
	
	\item Dokázateľná formula: $\vdash \varphi$, Dokázateľná z predpokladu: $T \vdash \varphi$
	
	\item Korektnosť: Dokázateľné je pravdivé ($\vdash \varphi \implies \models \varphi$)
	
	\item Úplnosť: Pravdivé je dokázateľné ($\models \varphi \implies \vdash \varphi$)
	
	\item Sporná = všetky formule sú dokázateľné.
	
	\subsection{LTS a Kripkeho štruktúra}
	
	\item $LTS = (S, A, \Delta)$ — stavy, akcie a prechody $\Delta \subseteq S \times A \times S$
	
	\item $K = (S, T, s_0, L)$ — kde $T \subseteq S \times S$, inicálny stav $s_0$ a proposition labelling $L: S \to 2^{AP}$. Väčšinou chcem $T$ totálnu.
	
	\item Prechodový systém — $T$ je množina prechodov kde prechod je deterministická funkcia ($T \subseteq \mathcal{P}(S \to S)$). Interpretujem ako že mám pomenované prechody.
	
	\subsection{Trace ekvivalencia a bisimulácia}
	
	\item Trace: jeden beh v LTS
	
	\item Trace ekvivalencia = množiny behov systémov sú rovnaké.
	
	\item Relácia $R$ je bisimulácia ak spĺňa, že ak $(s,t) \in R$ a $(s, a, s') \in \Delta_0$, tak musí existovať $(t, a, t') \in \Delta_1$ t.ž $(s', t') \in R$ a to isté opačne.
	
	\item Dva stavy sú bisimulačne ekvivalentné ak existuje nejaké bisimulácia v ktorej sú v relácií. 
	
	\item Relácia bisimilarity $\sim$ je najväčšia ekvivalencia ktorá je súčasne bisimulácia.
	
	\item Pozn.: Môžem mať situáciu kedy $p$ simuluje $q$ a $q$ simuluje $p$, ale rôznymi reláciami a teda neviem zostrojiť jednu bisimuláciu ktorá ich zjednotí (Príklad: jeden proces sa rozhodne neskôr a druhý sa rozhodne buď hneď alebo neskôr.)
	
	\subsection{Omega automaty}
	
	\item Omega regulárne jazyky sú tvaru $U.V^\omega$ kde $U$ a $V$ sú regulárne jazyky.
	
	\item Buchi automat $(Q, \Sigma, \delta, s_0, F)$ — stavy, abeceda, prechodová relácia (nedeterministická), inicálny stav, akceptujúce stavy.
	
	\item Automat akceptuje ak sa v slove nachádza stav z $F$ nekonečne často.
	
	\item Zobecnený Buchiho automat: Miesto $F$ mám množinu množín stavov a akceptujem ak prejdem každou z nich nekonečne často.
	
	\subsection{CPO a Fixed point}
	
	\item Complete lattice (úplný svaz): Každá podmnožina má suprémum aj infimum.
	
	\item Complete partial order (CPO): Každá nekonečná postupnosť $a_0 \sqsubseteq a_1 \sqsubseteq ...$ má v množine súprémum.
	
	\item Directed complete partial order (DCPO): Každá directed množina má suprémum. Directed množina je taká že po dvoch tam majú prvky upper bound.
	
	\item Pozn.: každý complete lattice je aj CPO, každý konečný complete lattice je aj DCPO.
	
	\item Veta o pevnom bode (Knaster-Tarski): Pre complete lattice $(L, \leq)$ a monotónnu funkciu $f: L \to L$ platí, že aj fixed pointy $f$ tvoria complete lattice.
	
	\item Veta o pevnom bode (Kleene): Pre DCPO $(L, \leq)$ a Scott-spojitú (monotónnu) funkciu $f: L \to L$ existuje najmenší pevný bod ktorý a je suprémom postupnosti $f^n(\bot)$. (Zjednodušenie je pre konečný complete lattice a monotónnu funkciu)
	
	\subsection{LTL}
	
	\item $\varphi ::= true \mid p \mid \neg \varphi \mid \varphi \lor \varphi \mid X\ \varphi \mid \varphi\ U\ \psi$
	
	\item Iné operátory: $F\varphi = true\ U \varphi$, $G = \neg F \neg \varphi$, $\varphi\ R\ \psi = \neg (\neg \varphi\ U\ \neg \psi)$ a $\varphi\ W\ \psi = (\varphi\ U\ \psi) \lor G \varphi$
	
	\item Formula ktorú nevyjadrím v CTL: $F(G(\phi))$
	
	\subsection{CTL}
	
	\item $\varphi ::= true \mid p \mid \neg \varphi \mid \varphi \lor \varphi \mid AX\ \varphi \mid E/A [\varphi\ U\ \psi]$
	
	\item Iné operátory: $EX \varphi = \neg AX \neg \varphi$, $E/AF \varphi = E/A[true\ U\ \varphi]$, $E/AG \varphi = \neg A/EF \neg \varphi$
	
	\item Formula ktorú nevyjadrím v LTL: $AG(EF(\phi))$
	
	\subsection{Real Time Systems}
	
	\item Procesor (aktívny), zdroj (pasívny), job (jednotka práce), task (periodicky sa opakujúci job)
	
	\item Release time $r$, execution time $e$, relative/absolute deadline $d/D$, period $p$, completion time $C$, response time $C - r$, utilization $\frac{e}{p}$, density tasku $\frac{e}{min(p, D)}$ ($\frac{e}{d - r}$ pre job)
	
	\item Hard: verification, Soft: validation
	
	\item Tasks: Periodic (hard), Aperiodic (soft), Sporadic (hard)
	
	\subsection{Distribuované systémy}
	
	\item Komunikujúce procesy prepojené sieťou (Iné modely: MapReduce).
	
	\item Sieť je buď synchrónna alebo asynchrónna (všeobecnejšie).
	
	\item Komunikácia je drahá — Komunikačná zložitosť (počet, res. veľkosť správ)
	
	\item Sieť môže mať rôznu topológiu: ring, star, grid, hypercube, torus, tree, complete graph, unknown
	
	\item Zlyhania procesov: nečakaný delay, jednorázové zlyhanie, zlyhanie a zotavenie, bizantínske zlyhanie
	
	\item Zlyhania siete: nečakaný delay, packet loss, packet duplication, packet reordering, bizantínske zlyhanie

	\section{Advanced pojmy}
	
	\subsection{Grafové problémy}
	
	\item Nezávislá množina: žiadne dva vrcholy v množine nie sú spojené hranou.
	
	\item Vrcholové pokrytie: každá hrana končí vo vrchole ktorý je v pokrytí.
	
	\item Dominujúca množina: každý vrchol má suseda v množine.
	
	\item Ofarbenie grafu: Každý vrchol má medzi susedmi unikátnu farbu.
	
	\item Hamiltonovský cyklus/cesta.
	
	\item Reprezentácia grafov: Matica susednosti, Incidenčná matica, zoznam následníkov (hrán), implicitne.
	 
	 \subsection{Logika}
	 
	 \item Úplný systém logických spojok: dá sa pomocou neho vyjadriť ľubovoľná logická funkcia. (Dôkaz pre ano/or/not - ľubovoľnú funkciu zákódujem do veľmi hnusného DNF)
	 
	 \item Shefferovská funkcia: úplná sama o sebe (zhruba 1/3 funkcií je shefferovská)
	 
	 \item Lukasiewicz (odvodzovacý systém pre výrokovú logiku):
	 
	 \begin{itemize}
		\item A1: $A \to (B \to A)$
		\item A2: $(A \to (B \to C)) \to ((A \to B) \to (A \to C))$
		\item A3: $(\neg A \to \neg B ) \to (B \to A)$
		\item MP (modus ponens): Z $A \to B$ a $A$ vyvoď $B$
	 \end{itemize}

	\item First order logic (odvodzovacý systém):
	
	\begin{itemize}
		\item A1-A3 + MP
		\item $\forall x . \varphi \to \varphi[x/t]$ (špecifikácia)
		\item $\forall x. (A \to B) \to (A \to \forall x. B)$ (ak $x$ nemá voľný výskyt v $A$, distribúcia)
		\item Generalizácia: Z $A$ odvoď $\forall x . A$
		\item Rovnosť: $x = x$, ak $x = y$, tak $f(x) = f(y)$ a ak $x = y \land P(x)$, tak $P(y)$.
	\end{itemize}

	\item Veta o dedukcií: Ak $T \vdash (A \to B)$ tak $T \cup A \vdash B$.
	
	\item Veta o kompaktnosti: Nekonečná teória má model práve keď každá konečná podteória má model.
	
	\item Löwenheim-Skolem: Ak pre ľubovolné $n$ existuje model s nosičom mohutnosti $n$, tak existuje aj nekonečný model.
	
	\subsection{Gödel}
	
	\item Peanova aritmetika — axiomy aritmetiky celých čísel v predikátovej logike.
	
	\item Gödelov predikát — $\beta(a, b, i, x) \iff x = a \mod (1 + b (1 + i))$ — kóduje unikátnu (konečnú) postupnosť čísel.
	
	\item 1. Veta o neúplnosti: Existuje formula pravdivá v $\mathcal{N}$ ktorá nie je dokázateľná v Peanovej aritmetike. 
	
	\item Proof sketch: Dôkazy sa dajú kódovať ako čísla, teda môžem mať predikát $proof(x, y)$ ak $x$ je dôkaz $y$, z tohoto dostanem predikát pre "$x$ je dokázateľné". Na základe toho potom skonštruujem formulu typu $\varphi = \neg provable(\varphi)$. Formula sa nazýva Gödel sentence.
	
	\item 2. Veta o neúplnosti: Formula $consis = \neg provable(a \land \neg a)$ (ekvivalentné dôkazu bezspornosti) nie je dokázateľná v Peanovej aritmetike pre ľubovoľné $a$ (ani iných podobne silných systémoch).
	
	\item Proof sketch: Použijem Gödel sentence $g$ ako $a$ a ukážem že ak $\vdash g$, tak aj $\vdash provable(g)$ a súčasne $\vdash \neg provable(g)$ (toto sa dá dokázať v PA, keďže $g$ je nedokázateľná). Potom ale z $\vdash provable(g)$ plynie $\neg consis$.
	
	\subsection{Logiky nad slovami}
	
	\item Predikátová logika — kvantifikujem nad pozíciami v slove a mám dva predikáty $Q_a(x)$ (na pozícií $x$ je znak $a$) a $x < y$.
	
	\item Pomerne slabá logika, nevie vyjadriť ani jazyk slov párnej dĺžky.
	
	\item Second order logic — pridávam kvantifikáciu nad množinami pozícií a predikát $x \in X$.
	
	\item Populárne predikáty: $next$, $last$, $first$... Množiny potom väčšinou definujem induktívne (existuje množina taká že jej prvok je prvý v slove a všetky jej prvky sú o dva za iným prvkom)
	
	\item FA to MSOL:
	
	\begin{itemize}
		\item Definujem si "partície" do ktorých sa mi rozpadnú pozície slova podľa toho či skončím v tom stave keď prečítam danú pozíciu.

		\item Inicializácia: Po prečítaní prvého znaku skončím v množine danej týmto znakom.
		\item Množiny pozícií sú dizjunktné a každá pozícia patrí do jednej množiny.
		\item Pozície zachovávajú prechodovú funkciu.
	
		\item Potom už stačí napísať že posledná pozícia leží v množine ktorá odpovedá akceptujúcemu stavu.
	\end{itemize}

	\item MSOL to FA:
	
	\begin{itemize}
		\item Postupujem induktívne po formuli. Konštruujem automat ktorý akceptuje slová abecedy $\Sigma \times [0,1]^n$ kde $n$ je počet voľných premenných a hovorí či je pozícia v danej premennej alebo nie (FO premenné budú mať v celom slove len jednu jednotku).
		
		\item Preklad predikátov je triviálny (proste sa presuniem keď na razím na vhodné kombo znak-príslušnosť)
		
		\item Negácia — nemôžem robiť hlúpy komplement, musím ešte zabezpečiť že nebudem akceptovať malformed slová (FO premenné s viac jednotkami). Viem ale urobiť jazyk validných slov, takže urobím komplement a sprienikujem s týmto jazykom.
		
		\item Dizjunkcia — rozšírim abecedy jazykov na rovnakú doménu (jeden prechod zdvojím aby šiel bez ohľadu na novú premennú). Potom môžem robiť union.
		
		\item Kvantifikácia — proste useknem celú pozíciu premennej z abecedy.
		
		\item Výsledný automat môže byť veľký — "veža exponentov" vhľadom k počtu negácií.		
	\end{itemize}

	\subsection{Omega automaty}
	
	\item Uzavretosť na zjednotenie (blbý union), zreťazenie regulárny+omega, res. regulárny$^\omega$
	
	\item Prienik: Konštrukcia ako pre prevod zobecneného automatu: Vytvorím vrstvy pre každý prienikovaný automat a behám medzi vrstvami pri prechode cez koncový stav.
	
	\item Komplement: Ano, ale dôkaz je fuj \textbf{??????} 
	
	\item Neprázdnosť jazyka je NLOG úplná (Reachability), Ne-univerzálnosť je PSPACE.
	
	\item Muller — množiny stavov, akceptujem ak $inf(w)$ presne matchuje jednu z množín.
	
	\item Rabin — páry množín, akcetujem ak existujé pár t.ž. $inf(w)$ má prienik s prvou ale nie s druhou.
	
	\item Street — páry množín, akceptujem ak pre všetky páry $inf(w)$ má prienik s prvou implikuje že má prienik s druhou.
	
	\subsection{Sémantiky: program}
	
	\item Program je reprezentovaný syntaktickým stromom (atomy majú doménu a môžu mať potenciálne svoj vlastný AST, ale to ma až tak nezaujíma)
	
	\item Domény: $Var$, $Bool$ a $Num$ 
	
	\item Aritmetické výrazy $a ::= Num \mid Var \mid a + a \mid a - a \mid a \cdot a$
	
	\item Booleovské výrazy $b ::= Bool \mid a = a \mid a \leq a \mid \neg b \mid b \land b \mid b \lor b$
	
	\item Príkazy: $c ::= skip \mid c;c \mid if\ b\ then\ c\ else\ c \mid while\ b\ do\ c$
	
	\subsection{Operačná sémantika}
	
	\item Pomocou odvodzovacieho systému popisuje ako program počíta.
	
	\item BigStep: Konfigurácia je valuácia premenných. Prechody sú označené príkazmi a existujú ak sú dokázateľné.
	
	\item Tvar odvodzovacieho systému zodpovedá vykonaniu celého príkazy (artimetika sa vyhodnocuje na čísla, Pravdivosť na 1/0, while sa vyhodnotí rekurzívne)
	
	\item SmallStep: Konfigurácia je zostávajúci program + valuácia premenných. Prechody nie sú označené a reprezentujú jednotlivé inštrukcie programu.
	
	\item Tvar odvodzovacieho systému zodpovedá vykonaniu jednej inštrukcie (idem z ľava do prava a redukujem list AST stromu, while sa vyhodnotí na jeden unroll, vyhodnotený príkaz sa zmení na skip, kompozíciu skipo + niečo viem zameniť za niečo)
	
	\item While môže mať nekonečný dôkaz ak cyklus nekončí (prechod neexistuje)
	
	\subsection{Denotačná sémantika}
	
	\item Pomocou funkcie popisujem čo program počíta.
	
	\item Funkcia mi pre program vracia funkciu transformácie stavu (res. výpočtu hodnoty na základe stavu pre artimetiku a bool).
	
	\item Funkcia je definovaná intuitívne, jediný problém je s while. $\mathcal{C}[while]$ je least fixed point funkcie $\Gamma(f) = \{ (a, a) \mid \mathcal{B}(a) = \bot \} \cup \{ (a,b) \mid \mathcal{B}(a) = \top \land b = (f \circ \mathcal{C}[c])(a) \}$ (funkcia je monotónna a zachováva supréma, teda je Scott-continuous a teda môžem použiť Kleeneho).
	
	\subsection{Axiomatická sémantika (Hoareho logika)}
	
	\item Nehovorí nič o ukončení programu! Len parciálna korektnosť.
	
	\item Hoareho trojica $A \mid c \mid B$ — Ak platí $A$ a $c$ skončí, bude platiť $B$.
	
	\item Hoareho odvodzovacý systém:
	
	\begin{itemize}
		\item Axióm: $A \mid skip \mid A$
		\item Axióm: $A[X/t] \mid X = t \mid A$
		\item Rule: $A \mid a;b \mid B$ ak $A \mid a \mid C$ a $C \mid b \mid B$
		\item Rule: $A \mid if\ b\ then\ c\ else\ d \mid B$ ak $(A \land b) \mid c \mid B$ a $(A \land \neg b) \mid d \mid B$
		\item Rule: $A \mid while\ b\ do\ c \mid (A \land \neg b)$ ak $(A \land b) \mid c \mid A$ ($A$ je invariant)
		\item Rule: $A \mid c \mid B$ ak $\models (A \implies A')$, $\models (B' \implies B)$ a $A' \mid c \mid B'$
	\end{itemize}

	\item Systém je korektný a úplný (vzhľadom na partial correctness)
	
	\item Úplnosť vyplýva z existencie weakest precondition.
	
	\item Weakest precondition: Pre statement a postcondition určí najslabšiu vstupnú podmienku. Teda $\vdash WP \mid c \mid B$ (Z WP viem dokázať B po c)
	
	\item Weakest precondition vždy existuje! (pri dôkaze while používam Godelov predikát)
	
	\item Konštrukcia WP:
	
	\begin{itemize}
		\item WP pre $skip, B$ je $B$
		\item WP pre $X = a, B$ je $B[X/a]$
		\item WP pre $a;b, B$ je WP pre $a$ z WP pre $b, B$
		\item WP pre $if, B$ je $(b \implies WP(c, B)) \land (\neg b \implies WP(d, B))$
		\item WP pre $while, B$ je $(b \land I) \implies WP(c, I)$ a $(\neg b \land I) \implies B$ (pozor, tie dve formule chcem kvantifikovať oddelene)
	\end{itemize}

	\subsection{LTL model checking}
	
	\item Kripkeho štruktúra na Buchi automat (všetky stavy sú akceptujúce)
	
	\item Vlastnosť na Buchi automat (exponenciálnej veľkosti ak mám smolu)
	
	\item Na to aby som ukázal $M \models \varphi$, potrebujem $L(M) \subseteq L(\varphi)$, to ale platí iff $L(M) \cap co-L(\varphi) = \emptyset$.
	
	\item Zostrojím teda kompozíciu automatov pre $M$ a pre $\varphi$ a v nej hľadám akceptujúcy cyklus.
	
	\item NestedDFS: Dve (súbežné) DFS — jedno mi určuje postorder akceptujúcich stavov, druhé mi z každého akceptujúceho stavu hľadá cyklus. Celková zložitosť je lineárna.
	
	\item Sú triedy vlastností ktoré sa overujú jednoduššie: safety — automat je terminálny (cyklus je selfloop), weak LTL (response vlasnosti) (komponenty sú buď akceptujúce alebo nie, nie sú mixed), stačí mi DFS.
	
	\subsection{Symbolický model checking}
	
	\item Stavy sú bitvektory. Mnoéžiny stavov sú množiny bitvektorov. Teda množina stavov je booleovská funkcia.
	
	\item OBDD — ordered binary decision diagram — mám usporiadanie na premenných a zlúčil som všetky duplicitné a redundantné vrcholy.
	
	\item Minimalizácia: Zlep listy, odstráň vrcholy ktoré majú identický low/high link, spoj dvojice vrcholov ktoré majú rovnaký low/high link (pre rovnakú premennú)
	
	\item Aplikácia funkcie — Shannonova expanzia $F(x, ...) = (x \land F_{x \to 1}) \lor (\neg x \land F_{x \to 0})$ — Postupujem rekurzívne od vrchu BDD až po listy. Keď prídem do listu, aplikujem funkciu, inak len traverzujem graf bližšie k listom (teda simulujem prácu s BDT pomocou grafu BDD). Výsledky potom rekurzívne zliepam a minimalizujem.
	
	\item Model checking: Iniciálne stavy sa kódujú ako BDD. Prechodová funkcia sa kóduje ako BDD (dvojnásobná veľkosť, doslova kódujem reláciu prechodu). Jeden krok sa kóduje ako konjunkcia s prechodovou funkciou a potom zahodenie a prvej polovice premenných.
	
	\item Bounded model checking: Kódovanie do SMT formule s unrollingom dĺžky $k$. Nie všetko sa dá takto dokázať ($GF a$).
	
	\subsection{Prevod LTL na Buchi}
	
	\item Formula obsahuje len X a U, R a negáciu len na literáloch (k tomu potrebujem R)
	
	\item Algoritmus najskôr vyrobí graf automatu, z neho urobí rozšírený automat a ten spojí na obecného Buchiho.
	
	\item Výroba grafu automatu:
	
	\begin{itemize}
		\item Každý stav si pamätá čo má ($Now$), čo chce ($New$) a čo potrebuje ($Next$).
		\item Začínam s jedným stavom ktorý má v seve ako new celú formulu.
		\item Postupne unrollujem podľa pravidla: Ak mám niečo v new, zamením tento stav za (jeden alebo viac) nových. Ak v new nič nie je, vyrobím nového následníka ktorý bude mať v new môj next.
		\item Ak vyrobím duplicitný stav, tak ho len mergnem.
		\item Unrolling propozície len overí či už náhodou neplatí jej negácia (ak ano, uzol sa maže a končím)
		\item Unrolling and/or je buď na dva stavy kde je ľavá/pravá ako new, alebo na jeden kde sú obidve ako new.
		\item Unrolling Nextu je že sa podformula pridá do next.
		\item Unrolling Untilu je na dva stavy, jeden kde je reach v now a jeden kde je path v now a until v next.
		\item Unrolling Release je na dva stavy, jeden kde sú obidve v now a jeden kde je path v now a release v next.
	\end{itemize}

	\item Výroba rozšíreného automatu: Prechody sú pod propozíciami ktoré platia v stavoch kam vedú. Pre každý until akceptujem množinou stavov kde v now buď je reach, alebo v now nie je celý until. (Teda ak raz vbehnem do miesta kde má platiť until, tak musím prísť až do reachu)

	\subsection{Process Rewrite Systems}
	
	\item Term $t ::= \epsilon \mid X \mid t . t \mid t || t$ (X je procesová konštanta)
	
	\item Pravidlá tvaru $t \to_a t$ ($a$ je akcia)
	
	\item Syntaktická ekvivalencia — nezáleží na zátvorkovaní po sebe idúcich kompozícií, paralelná kompozícia je komutatívna, epsilon môžem pridávať / odoberať kde len chcem.
	
	\item Sémantika je LTS (lable = akcie, stavy = termy). Prechod potom vznikajú podľa pravidiel s tým že pravidlo aplikujem buď priamo, alebo na prvý proces kompozície s tým že môžem použiť syntaktickú ekvivalenciu.
	
	\item Hierarchia termov:
	
	\begin{itemize}
		\item \textbf{1} bez kompozície
		\item \textbf{S} len sekvenčná kompozícia
		\item \textbf{P} len paralelná kompozícia
		\item \textbf{G} čokoľvek
	\end{itemize}

	\item Hierarchia (ostrá) na základe termov ktoré môžem používať na ľavej/pravej strane pravidiel.
	
	\begin{itemize}
		\item (1,1) - konečné automaty
		\item (1, S) - Basic Sequential Processes
		\item (1, P) - Basic Parallel Processes
		\item (S, S) - Pushdown jazyky
		\item (P, P) - Petriho siete
		\item (1, G) - Process Algebra
		\item (P, G), (S, G) a (G, G) nemajú mená
	\end{itemize}

	\subsection{Vybrané verifikačné problémy PRS}
	
	\item \textbf{TODO}
	
	\item Equivalence checking
	
	\item Petriho siete
	
	\item LTL pre pushdown systémy
	
	\subsection{Partial Order Reduction}
	
	\item Stuttering equivalence - vynechám všetky konečné duplicity a dostanem kanonický tvar slova.
	
	\item Nezávislosť prechodov: komutativita (a(b(s)) = b(a(s)) a enabledness (ak a,b enabled tak po vykonaní a/b je b/a stále enabled).
	
	\item C0 ample je prázdny iff enabled je prázdny
	
	\item C1 Ak existuje cesta (v pôvodnom grafe) na ktorej sa vykoná prechod z ample, tak všetky prechody predtým sú nezávislé na ample.
	
	\item C2 ak $ample \not= enabled$, tak všetky prechody v ample sú invisible
	
	\item C3 Ak existuje cyklus (v redukovanej štruktúre), t.ž. $a \in enabled$ pre nejaký vrchol na cykle, tak $a \in ample$ pre nejaký vrchol na cykle.
	
	\item Ako toto počítať? Zosilníme podmienky:
	
	\item Model: Paralelné procesy, message queues a shared variables. $pre(a)$ - konfigurácie v ktorých viem povoliť daný prechod, $dep(a)$ - závislé prechody (zdieľajú queue, shared variable alebo sú v tom istom procese), $current$ - prechody ktoré sú povoliteľné v tomto procese zmenou program counteru iného procesu, $T$ - prechody povolené v tomto procese.
	
	\item C3 - každý cyklus obsahuje jeden plne rozvitý vrchol (pri výrobe pomocou DFS teda rozvíjam vždy keď prídem späť na zásobník)
	
	\item C0 a C2 sú lokálne, nie je problém
	
	\item C1 - Testujem ako ample postupne sady povolených prechodov jednotlivých procesov. Musia splňovať že $dep$ neobsahuje prechod iného procesu a že $pre(current - T)$ neobsahuje prechod iného procesu.
	
	\subsection{Abstrakcia}
	
	\item Zjednodušiť systém pridaním/odobratím chovania.
	
	\item Presné abstrakcie: cone of influence (a podobné eliminácie nepotrebného balastu)
	
	\item Množina stavov programu sa nahradí abstraktným, jednodušším stavom.
	
	\item Buď abstraktné domény (+/0/-, mod, ...) alebo predikátová abstrakcia.
	
	\item May abstrakcia: Ak existuje $s \to s'$ tak musí existovať aj $h(s) \to h(s')$
	
	\item Must abstrakcia: Pre každé $s \in h^{-1}(a)$ t.ž. $a \to a'$ existuje $s' \in h^{-1}(a')$ t.ž. $s \to s'$ 
	
	\item Kartézska abstrakcia: ako predikátová, ale dovolím si extra symbol $*$.
	
	\item Ukážka: Guarded command language $(label, guard, update)$. Kontrolujem (v stave $b$) či $isValid(\varphi[b] \implies \neg guard)$, ak ano, prechod je nemožný. Inak testujem $b'_j = (\varphi[b] \implies (guard \implies \varphi_j[update(b)]))$, res. s negáciou keď chcem vedieť či môžem isto prejsť do 1/0. Ak nič z toho neplatí, idem do *.
	
	\item CEGAR — na základe protipríkladu chcem rozbiť existujúci abstraktný stav tak, aby som rozlýšil falošnú cestu od skutočnej.
	
	\subsection{Abstraktná interpretácia}
	
	\item Statická analýza — nezaujíma ma beh programu, ale aké stavy navštívia ktoré statementy.
	
	\item Pre každú inštrukciu definujem monotónnu funkciu a napočítavam globálny fixed point (buď najmenší alebo najväčší).
	
	\item Môžem použiť widening/narrowing operátory na urýchlenie.
	
	\item Príklad: živé premenné. Monotónna funkcia je (živéVNásledníkoch - priraďujem) + používam. (premenná je živa až PO priradení)
	
	\subsection{RTS: Plánovanie}
	
	\item Clock-driven — ak mám presný timer, môžem si predpočítať presný schedule na hyperperiod a ísť podľa toho. Väčšinou ale chcem schedulovať periodicky po framoch (frame musí byť väčší ako execution time, frame musí deliť hyperperiod a medzi release a deadline je aspoň jeden frame $2f - gcd(f,p) \leq D$)
	
	\item Ak sú joby moc veľké, môžem ich rozdeliť na dopredu daných miestach. Aperiodic/sporadic riešim tak, že počítam koľko mi ešte zostáva slack timu vo frame a podľa toho pridávam alebo nie (buď na začiatok alebo na koniec).
	
	\item Priority-driven s fixnou prioritou: Rate-monotonic (menšia perióda), Deadline-monotonic (menší deadline)
	
	\item Ak sú tasky simply periodic (periódy sú násobky seba), tak RM je optimálny (schedulable utilization 1). Ak $D \leq p$, tak DM je aspoň taký dobrý ako ľubovoľný fixed-priority algoritmus.
	
	\item Schedulable utilization pre DM je $n(2^{1/n} - 1)$ (konverguje k $ln(2)$).
	
	\item Schedulability test: Critical instant — okamih kedy má job tasku najväčší response time. Ak sú vo fáze, tak je to ten prvý, inak je to vtedy keď sú všetci s väčšou prioritou releasnutý tiež. Time demand analysis — funkcia vyjadruje koľko času potrebujem na vykonanie doteraz releasnutých taskov. Potrebujem aby v nejakom okamihu bola menšia ako uplynulý čas. Schedulability: Time demand analysis v critical instant.
	
	\item Sporadic jobs cez servery: Chová sa ako normálny periodický task, ale má okrem periody ešte aj budget. Polling server — obnovuje sa na perióde a ak nemá čo počítať, zahadzuje. Deferrable server — necháva si budget až do limitu, problém je, že môže blokovať na 2x čas. Sporadic server — vždy keď prvý krát začne počítať, nastaví replenishment time na t+p a nemení ho, pokiaľ celý systém nie je idle (ak je idle, nič nekonzumujem a vystúpenie z idle je "reštart systému"). Neblokuje ani zbytočne nezahadzuje.
	
	\item Priority-driven s dynamickou prioritou: Earliest deadline first a least slack time
	
	\item Schedulable utilization 1.
	
	\item Ak $D \geq p$, tak stačí test na utilization, inak treba pozerať na density, čo už je ale len nutná podmienka.
	
	\item Sporadic/Aperiodic tasky: periodické tasky mi rozsekajú čas na intervaly a v každom z nich musím otestovať či density aktuálne akceptovaných + periodických taskov je menej ako jedna.
	
	\item Resources: Priority inversion. Kritická sekcia má najväčšiu prioritu (blokujem všetkých, ale len na jednu kritickú sekciu). Priority inheritance — dedím prioritu tasku ktorý čaká na môj resource (blokujem len závislých, ale po dobu jednej sekcie od každého resourcu). Priority ceiling — resource má ceiling ako max. prioritu ktorá ho requestuje, systém ma ceiling ako max. blokovaný resource a resource môžem dostať len ak moja priorita je vúčšia ako ceiling systému (predchádza aj deadlockom, iba jedna krit. sekcia) 
	
	\subsection{distributed mutual exclusion}
	
	\item Väčšinou nejaká forma predávania tokenu (najjednoduššie na ringu).
	
	\item Lamport: Každý proces drží frontu requestov s ich kauzálnym timestampom. Keď chcem ísť do krit. sekcie, pošlem všetkým request a čakám na ack. Ak som stále na vrchole fronty, môžem ísť do krit. sekcie. Až skončím, pošlem všetkým release aby vedeli že si ma môžu vyhodiť von.
	
	\item Raymond: Kontra na grafe, koreň je tam kde je token. Interne si držím frontu requestov (od seba a susedov) a posielam requesty rodičovy v kostre. (ideálne log(n), ale potrebujem topológiu)
	
	\item Maekawa: Kvóra veľkosti sqrt(N) ktorých sa musím pýtať na povolenie. Kvóra majúvždy neprázdny prienik, takže ak dá kvórum green light, znamená to že žiadne iné kvórum nie je blokované.
	
	\subsection{Distributed termination detection}
	
	\item Dijkstra-Scholten: Request-ack dynamicky tvorený strom. Keď skolabuje, skončil som. (môžem sa niekoľko krát pripojiť/odpojiť ak ma viac krát objavia). Lineárna zložitosť.
	
	\item Safra: Token s flagom a message countom. Zložitosť je divná, ale v priemere dobrá.
	
	\subsection{Distributed leader election}
	
	\item Na cykle: Chang-Roberts — každý pošle token a čaká na jeho návrat a zabíja tokeny menších procesov (kvadratická)
	\item Na cykle: Paterson — Porovnám sa vpravo a vľavo a z týchto susedov vyhrávam. One direction problém: Jeden smer nevidím. Riešenie — identity kolujú po kruhu, jeden step za kolo. Takže ten kto dostane na konci svojho kola identitu pozná svoju starú a identitu dvoch ľudí za sebou. (nlogn)
	
	\item Na stromoch: Inicializácia z listov — čakám kým dostanem ponuku od všetkých až na jedného, potom pošlem ponuku ďalej a čakám na odpoveď.
	
	\item Obecná voľba vlnou: V každom vrchole sa iniciuje úplné prehľadávanie grafu. Horšie vlny sa pri strete zrušia. 
	
	\item Voľba kostrou (GHS): Každý začína ako nezávislá oblasť. V oblasti sa zvolí najmenšia hrana a so susedom dohodneme kto je väčší. Ak som väčší, čakám (sused ma sám poprosí), ak som menší/rovný, pridám sa k susedovi. 
	
	\item Voľba priechodom (KKM): Každý vrchol začne priechod grafu. Postupuje sa v kolách, ako pri Patersonovi. Priechody ktoré stretnú vrchol ktorý už je vo vyššom kole okamžite končia. Priechody ktoré stretnú vrchol ktorý videl horší alebo chasing token čakajú (buď ich niekto doženie, alebo lepší proste vyhrá). Priechody ktoré stretnú vrchol ktorý videl lepší token sa stanú chasing (a pokúsia sa ho dohnať a dostať na ďalší level). Pozn.: V každom leveli je jeden priechod ktorý nikdy nebude chasing, lebo vždy naháňam len lepšie tokeny. Najlepší token keď sa stane waiting, tak ho vždy niekto dobehne, lebo skôr či neskôr mu niekto zkríži cestu (alebo už skrížil predtým).
	
	\subsection{ISO/OSI model}
	
	\item Physical layer — bit-to-signal transformation, bit-rate control, bit synchronization, multiplexing, circuit switching
	\item Data Link layer — framing, addressing (MAC), Error control, Flow control, Medium Access Control
	\item Network layer — packetizing, internetworking (WAN), fragmenting, addressing (IP), Routing
	\item Transport layer — packetizing, addressing (porty), reliability, congestion/flow control, connection control (TCP vs. UDP)
	\item Session layer — 
	\item Presentation layer — transformácie dát
	\item Application layer — client/server, peer-to-peer, HTTP, FTP, SSH, ... 
\end{itemize}

\end{document}